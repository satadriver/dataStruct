CSDNҳ


ѧϰ

GitCode
InsCode
LZSS
 

Ա 
Ϣ
ʷ


ѹ㷨ר⡪LZSS㷨ʵ

Сͥ

 2019-12-28 12:17:44 

5163
 ղ 31
ר ѹ㷨ר ±ǩ LZSS ѹ
Ȩ

ѹ㷨ר
ר¼
4 ƪ16 
ר
һǰ
ǻҵһƪ͡ѹ㷨ר⡪ѹ㷨ܡĻʵֵģhttps://blog.csdn.net/qq_34254642/article/details/103651815һƪʵֻLZSS㷨ܣȲĽ㷨ЧʱȽϵͣǱ⡣дPythonC汾ԵĴṹһģж꾡ע͡ʵ˶ļѹͽѹܡ

 

LZSS㷨ʵ
Pythonʵ

import ctypes
import os
 
class LZSS():
    def __init__(self, preBufSizeBits):
        self.threshold = 2  #ȴڵ2ƥ䴮бҪѹ
        self.preBufSizeBits = preBufSizeBits  #ǰ򻺳ռõıλ
        self.windowBufSizeBits = 16 - self.preBufSizeBits   #ռõıλ
 
        self.preBufSize = (1 << self.preBufSizeBits) - 1 + self.threshold #ͨռõıλ㻺С
        self.windowBufSize = (1 << self.windowBufSizeBits) - 1 + self.threshold   #ͨռõıλ㻬ڴС
 
        self.preBuf = b''   #ǰ򻺳
        self.windowBuf = b''    #
        self.matchString = b''  #ƥ䴮
        self.matchIndex = 0     #ƥ䴮ʼ±
 
    #ļѹ
    def LZSS_encode(self, readfilename, writefilename):
 
        fread = open(readfilename, "rb")
        fwrite = open(writefilename, "wb")
        restorebuff = b''   #дݻһдһļ
        itemnum = 0     #8ĿΪһ飬ͳƵǰĿ
        signbits = 0    #ֽ
 
        self.preBuf = fread.read(self.preBufSize)   #ȡǰ򻺳
 
        # ǰ򻺳ûݿɲ˼Ϊѹ
        while self.preBuf != b'':
            self.matchString = b''
            self.matchIndex = -1
            #ڻѰƥ䴮
            for i in range(self.threshold, len(self.preBuf) + 1):
                index = self.windowBuf.find(self.preBuf[0:i])
                if index != -1:
                    self.matchString = self.preBuf[0:i]
                    self.matchIndex = index
                else:
                    break
            #ûҵƥ䴮ƥ䳤Ϊ1ֱԭʼ
            if self.matchIndex == -1:
                self.matchString = self.preBuf[0:1]
                restorebuff += self.matchString
            else:
                restorebuff += bytes(ctypes.c_uint16(self.matchIndex * (1 << self.preBufSizeBits) + len(self.matchString) - self.threshold))
                signbits += (1 << (7 - itemnum))
            #һĿ+1
            itemnum += 1
            #Ŀﵽ8ˣ˵һѹһдļ
            if itemnum >= 8:
                writebytes = bytes(ctypes.c_uint8(signbits)) + restorebuff
                fwrite.write(writebytes);
                itemnum = 0
                signbits = 0
                restorebuff = b''
 
            self.preBuf = self.preBuf[len(self.matchString):]  #ոƥƳǰ򻺳
            self.windowBuf += self.matchString  #ոƥݼ뻬
            if len(self.windowBuf) > self.windowBufSize:  #ݴǰ濪ʼƳ
                self.windowBuf = self.windowBuf[(len(self.windowBuf) - self.windowBufSize):]
 
            self.preBuf += fread.read(self.preBufSize - len(self.preBuf))  #ȡݲǰ򻺳
 
        if restorebuff != b'':  #ļܲһֱдļ
            writebytes = bytes(ctypes.c_uint8(signbits)) + restorebuff
            fwrite.write(writebytes);
 
        fread.close()
        fwrite.close()
 
        return os.path.getsize(writefilename)
 
    #ļѹ
    def LZSS_decode(self, readfilename, writefilename):
        fread = open(readfilename, "rb")
        fwrite = open(writefilename, "wb")
 
        self.windowBuf = b''
        self.preBuf = fread.read(1)  #ȶһֽȷôѹ
 
        while self.preBuf != b'':
            for i in range(8):  #8ĿΪһнѹ
                # ӱֽڵλʼ0ԭʼݣ1(±꣬ƥ)
                if self.preBuf[0] & (1 << (7 - i)) == 0:
                    temp = fread.read(1)
                    fwrite.write(temp)
                    self.windowBuf += temp
                else:
                    temp = fread.read(2)
                    start = ((temp[0] + temp[1] * 256) // (1 << self.preBufSizeBits))  #ȡλĻƥ䴮±
                    end = start + temp[0] % (1 << self.preBufSizeBits) + self.threshold  #ȡλƥ䳤
                    fwrite.write(self.windowBuf[start:end])  #ѹдļ
                    self.windowBuf += self.windowBuf[start:end]  #ѹͬд뵽
 
                if len(self.windowBuf) > self.windowBufSize:  #ƻڴС
                    self.windowBuf = self.windowBuf[(len(self.windowBuf) - self.windowBufSize):]
 
            self.preBuf = fread.read(1)  #ȡһݵı־ֽ
 
        fread.close()
        fwrite.close()
 
if __name__ == '__main__':
    Demo = LZSS(7)
    Demo.LZSS_encode("115.log", "encode")
    Demo.LZSS_decode("encode", "decode")
 
 
 
 

Cʵ

#include <string.h>
#include <stdio.h>
 
#define BYTE unsigned char
#define WORD unsigned short
#define DWORD unsigned int
 
#define TRUE 1
#define FALSE 0
 
BYTE bThreshold;  //ѹֵȴڵ2ƥ䴮бҪѹ
 
BYTE bPreBufSizeBits;  //ǰ򻺳ռõıλ
BYTE bWindowBufSizeBits;  //ռõıλ
 
WORD wPreBufSize;  //ͨռõıλ㻺С
WORD wWindowBufSize;  //ͨռõıλ㻬ڴС
 
BYTE bPreBuf[1024];  //ǰ򻺳
BYTE bWindowBuf[8192];  //
BYTE bMatchString[1024];  //ƥ䴮
WORD wMatchIndex;  //ƥ䴮ʼ±
 
BYTE FindSameString(BYTE *pbStrA, WORD wLenA, BYTE *pbStrB, WORD wLenB, WORD *pwMatchIndex);  //ƥ䴮
DWORD LZSS_encode(char *pbReadFileName, char *pbWriteFileName);  //ļѹ
DWORD LZSS_decode(char *pbReadFileName, char *pbWriteFileName);  //ļѹ
 
int main()
{
	bThreshold = 2;
	bPreBufSizeBits = 6;
	bWindowBufSizeBits = 16 - bPreBufSizeBits;
	wPreBufSize = ((WORD)1 << bPreBufSizeBits) - 1 + bThreshold;
	wWindowBufSize = ((WORD)1 << bWindowBufSizeBits) - 1 + bThreshold;
 
	LZSS_encode("115.log", "encode");
	LZSS_decode("encode", "decode");
	return 0;
}
 
BYTE FindSameString(BYTE *pbStrA, WORD wLenA, BYTE *pbStrB, WORD wLenB, WORD *pwMatchIndex)
{
	WORD i, j;
 
	for (i = 0; i < wLenA; i++)
	{
		if ((wLenA - i) < wLenB)
		{
			return FALSE;
		}
 
		if (pbStrA[i] == pbStrB[0])
		{
			for (j = 1; j < wLenB; j++)
			{
				if (pbStrA[i + j] != pbStrB[j])
				{
					break;
				}
			}
 
			if (j == wLenB)
			{
				*pwMatchIndex = i;
				return TRUE;
			}
		}
	}
	return FALSE;
}
 
DWORD LZSS_encode(char *pbReadFileName, char *pbWriteFileName)
{
	WORD i, j;
	WORD wPreBufCnt = 0;
	WORD wWindowBufCnt = 0;
	WORD wMatchStringCnt = 0;
	BYTE bRestoreBuf[17] = { 0 };
	BYTE bRestoreBufCnt = 1;
	BYTE bItemNum = 0;
	FILE *pfRead = fopen(pbReadFileName, "rb");
	FILE *pfWrite = fopen(pbWriteFileName, "wb");
 
	//ǰ򻺳ûݿɲ˼Ϊѹ
	while (wPreBufCnt += fread(&bPreBuf[wPreBufCnt], 1, wPreBufSize - wPreBufCnt, pfRead))
	{
		wMatchStringCnt = 0;  //տʼûƥ䵽
		wMatchIndex = 0xFFFF;  //ʼһֵʾûƥ䵽
 
		for (i = bThreshold; i <= wPreBufCnt; i++)  //ڻѰƥ䴮
		{
			if (TRUE == FindSameString(bWindowBuf, wWindowBufCnt, bPreBuf, i, &wMatchIndex))
			{
				memcpy(bMatchString, &bWindowBuf[wMatchIndex], i);
				wMatchStringCnt = i;
			}
			else
			{
				break;
			}
		}
 
		//ûҵƥ䴮ƥ䳤Ϊ1ֱԭʼ
		if ((0xFFFF == wMatchIndex))
		{
			wMatchStringCnt = 1;
			bMatchString[0] = bPreBuf[0];
			bRestoreBuf[bRestoreBufCnt++] = bPreBuf[0];
		}
		else
		{
			j = (wMatchIndex << bPreBufSizeBits) + wMatchStringCnt - bThreshold;
			bRestoreBuf[bRestoreBufCnt++] = (BYTE)j;
			bRestoreBuf[bRestoreBufCnt++] = (BYTE)(j >> 8);
			bRestoreBuf[0] |= (BYTE)1 << (7 - bItemNum);
		}
 
		bItemNum += 1;  //һĿ+1
 
		if (bItemNum >= 8)  //Ŀﵽ8ˣ˵һѹһдļͬʱջ
		{
			fwrite(bRestoreBuf, 1, bRestoreBufCnt, pfWrite);
			bItemNum = 0;
			memset(bRestoreBuf, 0, sizeof(bRestoreBuf));
			bRestoreBufCnt = 1;
		}
 
		//ոƥƳǰ򻺳
		for (i = 0; i < (wPreBufCnt - wMatchStringCnt); i++)
		{
			bPreBuf[i] = bPreBuf[i + wMatchStringCnt];
		}
		wPreBufCnt -= wMatchStringCnt;
 
		//ڽҪǰǰĲƳ
		if ((wWindowBufCnt + wMatchStringCnt) >  wWindowBufSize)
		{
			j = ((wWindowBufCnt + wMatchStringCnt) - wWindowBufSize);
			for (i = 0; i < (wWindowBufSize - j); i++)
			{
				bWindowBuf[i] = bWindowBuf[i + j];
			}
			wWindowBufCnt = wWindowBufSize - wMatchStringCnt;
		}
 
		//ոƥݼ뻬
		memcpy((BYTE *)&bWindowBuf[wWindowBufCnt], bMatchString, wMatchStringCnt);
		wWindowBufCnt += wMatchStringCnt;
	}
 
	//ļܲһֱдļ
	if (0 != bRestoreBufCnt)
	{
		fwrite(bRestoreBuf, 1, bRestoreBufCnt, pfWrite);
	}
 
	fclose(pfRead);
	fclose(pfWrite);
 
	return 0;
}
 
DWORD LZSS_decode(char *pbReadFileName, char *pbWriteFileName)
{
	WORD i, j;
	BYTE bItemNum;
	BYTE bFlag;
	WORD wStart;
	WORD wMatchStringCnt = 0;
	WORD wWindowBufCnt = 0;
	FILE *pfRead = fopen(pbReadFileName, "rb");
	FILE *pfWrite = fopen(pbWriteFileName, "wb");
 
	while (0 != fread(&bFlag, 1, 1, pfRead))  //ȶһֽȷôѹ
	{
		for (bItemNum = 0; bItemNum < 8; bItemNum++)  //8ĿΪһнѹ
		{
			//ӱֽڵλʼ0ԭʼݣ1(±꣬ƥ)
			if (0 == (bFlag & ((BYTE)1 << (7 - bItemNum))))
			{
				if (fread(bPreBuf, 1, 1, pfRead) < 1)
				{
					goto LZSS_decode_out_;
				}
				fwrite(bPreBuf, 1, 1, pfWrite);
				bMatchString[0] = bPreBuf[0];
				wMatchStringCnt = 1;
			}
			else
			{
				if (fread(bPreBuf, 1, 2, pfRead) < 2)
				{
					goto LZSS_decode_out_;
				}
				//ȡλĻƥ䴮±
				wStart = ((WORD)bPreBuf[0] | ((WORD)bPreBuf[1] << 8)) / ((WORD)1 << bPreBufSizeBits);  
				//ȡλƥ䳤
				wMatchStringCnt = ((WORD)bPreBuf[0] | ((WORD)bPreBuf[1] << 8)) % ((WORD)1 << bPreBufSizeBits) + bThreshold;
				//ѹдļ
				fwrite(&bWindowBuf[wStart], 1, wMatchStringCnt, pfWrite);
				memcpy(bMatchString, &bWindowBuf[wStart], wMatchStringCnt);
			}
 
			//ڽҪǰǰĲƳ
			if ((wWindowBufCnt + wMatchStringCnt) > wWindowBufSize)
			{
				j = (wWindowBufCnt + wMatchStringCnt) - wWindowBufSize;
				for (i = 0; i < wWindowBufCnt - j; i++)
				{
					bWindowBuf[i] = bWindowBuf[i + j];
				}
				wWindowBufCnt -= j;
			}
 
			//ѹͬд뵽
			memcpy(&bWindowBuf[wWindowBufCnt], bMatchString, wMatchStringCnt);
			wWindowBufCnt += wMatchStringCnt;
		}
	}
 
LZSS_decode_out_:
 
	fclose(pfRead);
	fclose(pfWrite);
	return 0;
}
 
ܷ
Ϊ붼ʵ֣ûжƥ䴮ŻʱϱȽϵֻͣԱѹǰļֽڴСһҪᵽľǴиthresholdΪ2˼ƥ䴮ڵ2бҪѹΪλãȣǵΪ16λƥ䴮ֻ1ֽҲַʽʾĻȻ𲻵ѹЧһԷһ⣬дļʱƥ䳤ȲʵֵΪ01ƥ䳤ǲڵģԸɴ0213Ϳ԰ƥ䳤ˡ

ȷˣλãȣʽΪֽں󣬽ôѡȡλá͡ȡӦռõıλǶˣǿΪ8,89,710,6ȵϣǸλáõıλһҪڵڡȡıλԭǻڴСҪڵǰ򻺳СȻû塣ͬļѡȡͬôѹҲ᲻ͬҶһlogļѡȡͬĲѹļСԱͼͼpreBufSizeBitsָġȡռıλ



 δѹԭʼļС5.06MBĿpreBufSizeBitsԽСԽãҲԽԽãΪpreBufSizeBitsС˵Ļôǰ򻺳ҲСˣһƥݴСˣpreBufSizeBits˵ĻôȻǰ򻺳ˣǻڻСݴƥ䷶ΧͱСˡҪѡһʵֵʹļѹá

㷨ڲĶԱȾ͵ˣǺ͵ǰеZIPRARѹܶԱȣȻоԲжԱȲн



115.logԭʼļencode2encode8ʵϱͼﲻͬpreBufSizeBitsʱɵѹļdecode2decode8ǶӦٽѹļ115.rarõRARѹļ115.zipõZIPѹļ㷨õѹ197KBZIP161KB಻ر󣬺RARͲ൱һˡ ΪZIPʵҲƵĻƥѹԽŻLZSS㷨ĻҪZIPܿ롣

ġܽ
˼LZSS㷨ĸĽѹʺѹ/ѹʱܣΪұǶʽʦԻ˼ʵǶʽ豸ѹϲϵʱҲҵһЩԴѹ⣬ʹϿܻһЩƣȻʹõ㷨֪֪׵ģǾͿԸĿص޸ĺãʲôҲ̫š

֪ʶٷ֪ʶƥ䣬ɽһѧϰ֪ʶ
㷨ҳ45521 ϵͳѧϰ

Сͥ
ע

7


31


5

רĿ¼
LZSSѹ㷨C++Դ
02-07
LZSSѹ㷨C++Դ룬Ѿװclass
о-һֻLEDʾϵͳLZSSĽ㷨 .pdf
08-14
һֻLEDʾϵͳLZSSĽ㷨ǿ޺죬LZSSѹ㷨ĻϣһָʺLEDʾϵͳĸĽѹ㷨㷨ͨѹֶνѹķʽûʧ??
5 
tangmiyu1987

һѹ㷨
д
LZSS㷨_lzss_lightdĲ
4-25
LZSS㷨 쿴LZSS.C,Ǹ4/6/1989 Haruhiko Okumuraľ롣 ܾûо㷨,ûϸ,ֻܴӴעȥ⡣滨Ҳʱ䡣 Ƚѹ,LZSSı1 byteflag,ӵ͵,bit=1...
LZSS㷨(C)_뻨׵Ĳ
4-22
LZSS㷨(C) #include<stdio.h>#include<stdlib.h>#include<string.h>#include<ctype.h>#defineN 4096#defineF 18#defineTHRESHOLD 2#defineNIL Nunsignedlonginttextsize=0,codesize=0,printcount=0;unsignedchartext_buf[N+...
compc++.zip_lzari_rle8_ѹ㷨_ͼ_ѹ
07-14
аһЩȽͨõѹ㷨Դ룬һЩͼʽôЩкܴǻа㷨Уlzarilzhuflzsslzwlz77huffmanrle8rle16ߣͨC 
ʵLZARIѹ㷨C++
03-15
:VC/C++Դ,㷨,ѹ,㷨,LZARIһLZARI㷨ѹࡪlzari.cṩlzariѹ㷨ĺʵ֣㷨198974Cʵ֣һЩȫֻ̬ıMFCʹúܲ㣬ҲΪΰһC++ԭʹܹѹͽѹ
ʵLZWֵѹ㷨_ԶǷĲ
4-14
LZSS㷨: 1.ӵǰѹλÿʼ,δַ,ͼڻҳƥַ,ƥַȴڵСƥ䴮,Ĳ2,в3; 2.ָԪ(off,len)offΪƥַ...
ĽLZSSѹ㷨_happylife1527Ĳ
4-21
ѡıļѹ,ԴļСΪ1.5 Mb,øĽLZSS㷨ѹԼΪ0.23Mb(ڲͬļݵĹɲһ,ѹıͬ,3),ݵĴʱδѹǰl/6,ЧԺȶԾõ֤ѡһ...


ѹ㷨Դlzw lzss LZHUF LZARI
02-02
ѹ㷨Դļlzw lzss LZHUF LZARI
ƼݼݱLZSS㷨Snappyѹ⼰ֲʽͨϵͳĽ⣨ͼĽ ϸ
·
showswollerĲ
 504
ƼݼݱLZSS㷨Snappyѹ⼰ֲʽͨϵͳĽ⣨ͼĽ ϸ
LZSS㷨ѧϰ
@evan_wu163
 538
ѹݷLZSS(Lempel-ziv-storer-szymanski)һѹһֵ뼼ͼٱʾƽĻ벻ͬLZSSöͬһֵַλõַ ......
 ѹ㷨  LZ 㷨
Υ֥
 2669
һȤѹ㷨
LZSS ѹ㷨 Ƭ lz77/lz78/lzw ǿ)ֲ
 890
http://wenku.baidu.com/view/5f654666f5335a8102d2204f.html LZSSѹڵƬϵͳϵӦо_ٶĿ   lzssѹ/ѹ㷨 http://download.csdn.net/download/pandaguy623/4321284
lzssѹ㷨
05-01
һȫȫlzssѹ㷨Դ
Դlzssѹ㷨Դ.rar
02-17
Դlzssѹ㷨Դ.rar
lzssѹ㷨
07-21
lzssѹ㷨Դ,lzssѹ㷨,lzssѹ,lzssѹ,int,del
LZSSѹ㷨

 1+
һ׼򵥵LZSS㷨룬һ£CRC32ʱ䣩£ ļͣWordDOCĵ ļ217 ļֽ9,196,346ֽڣ8.77MB) ƽѹʣ70%ѹ󳤶ԭȵ30% ѹʱ䣺8766루Լÿ1MB ѹʱ䣺795루Լÿ11MB
ѧϰLZ77LZSS㷨й
artmcuר
 9541
   ʵ ೡϣʼʱ֪ҪݵͳԣҲһ֪ǵͳԡˣѹͼЩݽѹ룬ʵʱԾܻѹȡЩͳΪͨñ뼼ʵ(Dictionary Encoding)һּ࣬ѹ һʵ ʵĸݱ
ѹظɾ
Ƽ
ר
 2+
ѹظɾּкϵأʵָȷӦأ֮ǰѹԭͼûо˵㹦ΣϣظɾжԱȷ
о-LZ77ѹ㷨Ľ .pdf
08-22
LZ77ѹ㷨ĽɣϢĲӣӦѹ㷨ϢѹԵԽԽҪĽLZ77ѹ㷨ʵ㷨LZSSڴ˻?
LeetCodeisPalindrome ĴJAVA
ȵСƼĲ
 799
һַ֤ǷǻĴֻĸַԺĸĴСд ˵УǽַΪЧĻĴ ʾ 1: : A man, a plan, a canal: Panama : true ʾ 2: : race a car : false class Solution { public boolean isPalindrome(String s) { //ԭַתΪַ鲢жǷΪַĸ //ͳһת
ZIPѹ㷨ϸѹʵ
YiRong
 4716
ŮϵУѹɳд档 鿴ͼ 鿴ͼ 鿴ͼ 鿴ͼ 鿴ͼ 鿴ͼ 鿴ͼ 鿴ͼ 鿴ͼ 鿴ͼ 鿴ͼ 
LZ77ѹ㷨ԭ(ͼƬͼ򵥴)
weixin_30871701Ĳ
 958
ǰ LZ77㷨ѹ㷨ɫAbraham Lempel1977ꡣLZ77ǵ͵Ļֵѹ㷨ںܶѹǻLZ77ѹĵλĽͼƬԴϸԭ ԭܣ Ƚܼרҵ 1.lookahead buffer(֪ôıʱΪ): ȴ...
Ƽаô

ǳû

û

һ

а

ǳа

ʿ

Ѱ󱨵

400-660-0108

kefu@csdn.net

߿ͷ
ʱ 8:30-22:00
11010502030143
ICP19004658
ġ20201039-165
ӪվϢ
ΥͲϢٱ
ҳ໤
110
йٱ
Chrome̵
˺Ź淶
Ȩ
Ȩ
֤
Ӫҵִ
?1999-2023֪缼޹˾

Сͥ
7
 ֤
40
ԭ
4+

10+

19+


ȼ
2724

242
˿
381

104

1627
ղ
ѧͽ
ǩ
ǩ
ǩ

ԭ̽
ʸ

ѧϰ
Ȧ֤
ԭ
Ķѫ
˽
ע
Ѳ


ר⡪Է루1  14815
ר⡪Էľ  12084
STM32ʹSRAMչڴ  11906
ѹ㷨ר⡪ѹ㷨  10083
emWinר⡪emWin鼰ģʹ  9997

ѹ㷨ר⡪miniLZO
С¹linux: ллˮ

ר⡪Է루1
ɰ: 65 ǳл

ucosucosֲs3c2440
Сʱͦؼ: 2440ƬRAMֻ4kUCOS3̫֪ʹƬRAM

ר⡪Է루1
ɰ: Ҳ ҵ

CMDִʱס
Shark_2021: ̫ˣ֮ǰס Ҫس һֱʲôԭ

ԸƼҳ

ǿҲƼ

Ƽ

һ

Ƽ

ǿƼ

һͨ۸ض޸ǶʽƷBUGķ
BLEHID豸ʵ֣ĸˡ̡ꡢHID豸
USBSTM32ģU̽IAP
20222ƪ20211ƪ202038ƪ20195ƪ20181ƪ


Ŀ¼
һǰ
LZSS㷨ʵ
ܷ
ġܽ


ר

STM32
10ƪ

BLE
1ƪ

ѹ㷨ר
4ƪ

USB
2ƪ

RTOS
1ƪ

JZ2440ʵ
8ƪ


2ƪ

C
1ƪ

51Ƭ

FPGA
2ƪ

ݾ㷨
4ƪ

QT
1ƪ


2ƪ

NESר
5ƪ

emWinר
1ƪ




ٱ